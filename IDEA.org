* Compiler Configuration
START [2024-06-22 Sat 18:55]
FINAL ?

Okay this is just brainstorming...

- Compiler configuration provided in a file like =--compiler-config /path/to/config=
- Compiler configuration provided in LISP build file i.e. =(compiler (executable-template "..."))=

I think I like the "in the build file" one at the moment.

=(compiler NAME EXECUTABLE-TEMPLATE LIBRARY-TEMPLATE)=

=(use-compiler TARGET NAME)=

The idea would then be to have some reasonable, default compilers defined (Using =cc= for C, =c++= for C++, etc), and the user can extend the system to do anything they need it to (like use a specific compiler).

NOTE: Important to note that =(compiler FOO)= will overwrite the compiler named =FOO= even if it already exists; this will allow people to easily change the C compiler for a project just by redefining =cc= at the top/beforehand or anything like that, and they won't have to dig through every build file to replace the name in =use-compiler=.

* Consolidation Idea
START [2024-06-22 Sat 18:52]
FINAL [2024-06-22 Sat 19:36]

Current executable target example:
#+begin_src lisp
(executable lbs)
(include-directories lbs inc)
(sources lbs src/main.cpp)
(flags lbs -Wall -Wextra -Wpedantic -Werror)
(dependency lbs libparser)
(dependency lbs libtests)
#+end_src lisp

Proposed executable target example:
#+begin_src lisp
(executable lbs
  (include-directories inc)
  (sources src/main.cpp)
  (flags -Wall -Wextra -Wpedantic -Werror)
  (dependency libparser)
  (dependency libtests))
#+end_src lisp

Why? Because I keep making the mistake of having the wrong target name as the second argument due to copy-and-paste errors and such.

* OLD LISP Build System README

This is just an idea for now: CMake but a locally-built LISP so you can see and edit the code that makes up the primitives, macros, etc.

#+begin_src lisp
;; Use like: lbs foo
;; NOTE: Since we promote a locally-built (probably bootstrapped) lbs
;; binary, the path to the executable may be ./lisp-build-system/bld/lbs

(library libfoo)
(sources libfoo libs/foo/foo.c)

;; A target (executable, library, etc) may have an ordered list of
;; requisites (like builtins, shell commands, /dependencies/, and more)
;; associated with it.
(executable foo)
(sources foo src/main.c)
;; Copy directory at ./foo into ./bar, resulting in ./bar/foo/
;; Nerd talk: Registers a requisite of type "builtin_copy" within the
;; target "foo".
(copy foo '(directory "./foo") '(directory "./bar"))
;; Copy contents of directory at ./foo into ./bar
(copy foo '(directory-contents "./foo") '(directory "./bar"))
;; Build dependency libfoo
(dependency foo libfoo)

;; NOTE: The order matters; the above will do the directory copying, build
;; the dependency libfoo, and only then attempt to build the target itself
;; (the foo executable).

;; Generic target to get things done, group tasks, whatever you'd like.
(target my-target)
(command my-target "echo hello from LISP-land (:^)")
(command my-target '(echo idn't this neat?))
(dependency foo my-target)
#+end_src lisp

It would be cool to have a =(watches)= sort of thing that is similar to =(sources)= in that it takes a list of files and if any of those files (maybe eventually directories) change the target gets revalidated (re-built).

** PAIN POINTS

- Which compiler to use, flags to give it to produce executable vs library, change output filename, etc.
